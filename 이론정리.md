## 모델링의 특징
- 추상화, 단순화-약속된표기법
- 명확화

## 모델링 시 유의사항
중복 최소화
비유연성최소화
비일관성 최소화

## 데이터 모델링 단계
= 개논물
개념적, - 엔터티, 속성을 도출한다.
논리적, = 관계를 도출한다., 정규화를 통해 중복데이터를 최소화한다.
물리적 - 디스크, 메모리 가장 구체적인 ., 성능, 보안, 가용성
추상화 수준이 점점 낮아진다.


## 스키마 (구조)
= 외개내
외부스키마 = 다중 사용자뷰
개념스키마 = 설계자관점(통합된 뷰!) 제공
내부스키마 - 개발자관점(물리적뷰)

## 데이터 독립성
의존성이 낮아지면 시스템의 유지보수성이 좋아진다. 

데이터 독립성을 유지하는 것이 외부 스키마 구조이다.

---
---

## 엔터티
유형무형
유개사 유형개념사건 
발생시점
기중행 기본중심행위

엔터티의 개념
엔터티의 특징
엔터티 = 데이터베이스의 구성요소 중 독립적으로 식별 가능한 객체
엔터티의 특징 !!!!!!!!

업무에서 필요로 하고 관리하고자 하는 정보여야 함
식별이 가능하도록 유일한 식별자를 가져야 한다.
영속적으로 존재하는 인스턴스가 두 개 이상인 집합을 이루어야 한다.
하위요소로 반드시 속성 attribute 을 가져야한다.
property는 그 객체의 특성

엔터티는 다른 엔터티의 한 개 이상의 관계를 가져야한다.
엔터티 = 테이블 = 릴레이션(relation)

속성 = 엔터티의 하위요소, 회원엔터티라고 하면 회원명, 회원주소, 대출증 번호 등이 속성이다.
의미상으로 분리되지 않는 최소의 데이터 단위** 걍 외워
꼭 필요한 것 위주로 최소화해야함!!

속성값 - 하나의 엔터티 인스턴스에서 각각의 속성은 하나의 속성값만을 지닌다.

엔터티, 인스턴스, 속성값

한 개의 엔터티는 두 개 이상의 인스턴스를 가진다.
한 개의 엔터티는 두개 이상의 속성을 가진다.
한 개의 속성은 한 개의 속성값을 가진다.
*** 속성의 특성에 따른 분류

기본 속성 : 엔터티가 본래부터 가지고 잇어야 하는 속성
설계 속성 : 엔터티가 본래부터 가지고 있었던 속성은 아니지만 설게시!!필요
파생 속성 *** : 다른 속성으로 부터 계산되어 특정 규칙에 따라 변형되어 만들어진 속성
PK(기본키) vs 일반속성

도메인 = 개념적으로 중요함
속성이 가질 수있는 값의 범위( 값의 *데이터 타입과 크기 등의 조건)을 정의한 것.
ex. 주문이라는 엔터티가 있을 때 단가라는 속성값의 범위는 10에서 1,000사이의 정숫값이며, 상품명 속성은 길이가 
30자리 이내의 문자열이다.

### 속성
엔터티, 인스턴스, 속성, 속성값의 관계 - 한 개의 엔터티는 2개 이상의 인스턴스의 집합이어야 한다(하나의 테이블은 두 개 이상의 행을 가짐) - 한 개의 엔터티는 2개 이상의 속성을 갖는다(하나의 테이블은 두 개 이상의 컬럼으로 구성됨) - 한 개의 속성은 1개의 속성값을 갖는다(각 컬럼의 값은 하나씩만 삽입 가능) - 속성은 엔티티에 속한 엔티티에 대한 자세하고 구체적인 정보를 나타

----
----

## 식별자(실선)
엔터티 간의 **강한** 연결 관계를 표현
부모 소멸할 때 자식도 같이 소멸 => 생명주기를 같이 갖는다.
자식이 부모의 회원번호를 참고하는 예시에서 
부모가 지워지면 자식의 회원번호도 같이 지워짐


## 비식별자(점선)
엔터티 간의 **약한** 관계를 표현
부모가 삭제되도 자식은 있을 수 있다. 
부모(회원번호) 자식(열람번호) 일때 회원번호를 일반속성으로 가진다.
일반속성은 Null 일수도있고 중복될수도있음

```
기출보기)
식별자관계에서는 pk가 자식에서 기본키가 자식의 자식으로 연결된다. 
비식별자관계에서는 자식의 자식으로 연결되지 않음.
```
---
---
# 정규화

1. 스탠다드
2. 노멀

**이상현상**
문제가 나타나는것
1. 삽입이상
2. 갱신이상
3. 삭제이상

정규화는 이상현상을 방지하기 위해 존재
데이터베이스를 보다 잘 조직화하기 위해
데이터의 중복을 최소화하면서

## 정규화의 결과
- 정규화를 수행하면 조인의 횟수가 증가함에 따라 조회성능이 떨어진다. (무조건적인 하락은 아님!!!)
- 데이터의 입력, 수정, 삭제 성능 향상


정규화를 수행하게 되면 테이블에 분해되는데 전체적인 시스템은 향상될 수 잇다.
불필요한 트랜잭션 (데이터 삽입, 의존성) 이 줄어들기 때문

## 정규화절차
1. 제1정규화
2. 제2정규화
3. 제3정규화
까지만 이해하자

1. 제1정규화
Q. 다음 모델링 결과의 문제점을 해결하시오
- 릴레이션의 속성값이 모두 ***원자값*** 만으로 구성되어야 한다.
=> 다시말해 속성값이 원자값이 아니면 고쳐야한다.
2개이상인 경우, 유사한 속성이 반복되는 경우 고쳐야함.
- 중복값을 제거
- 기본키를 설정해야한다.

2. 제2정규화
- 기본키가 2개 이상의 속성으로 이루어진 경우 부분 함수종속성을 제거한다.
* 함수종속성(FD)
    => 속성간에 의존성을 말함
    함수적 종속관계를 가져야한다.  
3. 제3정규화
- 기본키를 제외한 칼럼 간의 종속성을 제거한다. 이행 함수종속성을 제거한다.

## 제1정규화 (비정규형 -> 1차 정규형)
- 하나의 속성은 반드시 하나의 속성값을 가져야 한다. 
***정규화와 정규형을 구분하기***
*** 정규화를 통해 정규형이 만들어지는거다!! ***
-> 1차 정규화를 한 결과가 제 1 정규형이 되는거다.

1:다 관계를 1:1 관계로 만든다.

***하나의 테이블이 1차 정규화로 인해 두개로 나눠질때 PK 와 일반속성은 1:1 의 관계를 가져야하는데 유사한 속성이 반복됨에 따라 1:M 의 관계를 가졌었고,
그것을 두개의 테이블로 쪼갠 그 테이블끼리는 1:M의 관계를 갖게 된다.***💕💕

즉, 1차정규화로 만들어진 두개의 테이블은 1:다 의 관계를 갖는다. 💕💕

## 제2정규화 (1차 정규형 -> 2차 정규형)
***PK가 복합식별자인 경우*** 일반 속성이 주식별자의 일부에만 종속성을 갖는 
***부분 함수 종속성 제거*** 
=> 기본키에 들어가는 속성이 2개인 경우 
***부분함수종속성제거***

얘도 일대다 관계@!!

## 제3정규화
- 주식별자가 아닌 일반 속성 간에 함수종속성이 존재하는 이행 함수종속성을 제거
PK에 의해 일반속성이 결정되어야하는데 

* 이행함수종속성 
    => A가 B를 결정하고, B가 C를 결정하면, A가 C를 결정한다. 

***3차정규화에서는 비식별관계가 된다.!!***

정규화가 완벽하게 이루어진 다음 반정규화를 한다.

---
---

# 관계와 조인의 이해
(반정규화의 일부분 - 테이블 병합)
왜 하느냐 => 조회성능향상!
- 원투원타입 = 개별로 발생되는 트랜잭션에 대해 개별 테이블로 구성
- 플러스 타입 = 슈퍼타입+서브타입테이블
- 싱글타입= 전체를 하나의 테이블로 통합

💕 JOIN, UNION 이든 테이블 병합하는 현상인데 , => CPU 부화를 유발한다.!!!!


---
---
## NULL 속성의 이해
- 정해지지 않은 값 
- 미정의 된 값

1. 단일행 연산
1+NULL = NULL
2. 다중행 연산
NULL 값인 행을 제외하고 연산 수행

---
---

## 본질식별자 VS 인조식별자
1. 본질식별자 : 업무에 존재하는 원래의 식별자로, 원조식별자라 한다.
=> 원래 있는 데이터
- 꼭 필요한 식별자


2. 인조식별자 : 업무에 존재하지 않았으나@@1!! 원래의 식별자가 너무 복잡하게 구성되어 잇어 인위적으로 만든 식별자, 대리식별자라고도 한다.
    - 식별자가 복합식별자일 때 주로
- 꼭 필요하지는 않음      

💕💕 따라서 인조식별자는 다음과 같은 단점을 가진다.
1. 중복 데이터 발생 가능성 -> 데이터 품질 저하
2. 불필요한 인덱스 생성 -> 저장공간 낭비 및 DML 성능 저하

-> 인덱스는 원래 조회성능을 향상시키기 위한 객체이며, 
    인덱스는 DML(INSERT/UPDATE/DELETE)시 INDEX SPLIT 현상으로 인해 성능이 저하된다. 

근데 왜 만드냐 ? 
=> 추가적인 연산없이 시퀀시나 키 제약조건 등을 통해 주식별자를 생성할 수 있으므로 개발의 편의성이 향상될 수 잇다. (개발시간줄이고 비용줄인다.)

-----------------
-----------------








