## 2. 엔터티
- 업무를 반영한 독립적인 객체
- 객체는 물리단계로 되면 테이블로 설계가 되고, 논리단계에서는 엔터티라고 표현함 
- 테이블은 행과 열로 구성되어있는데 , 논리적 단계에서는 인스턴스라고 표현하고, 컬럼들을 속성이라고 표현함
- 보통 다른 속성들은 주식별자에 의해 결정이 되기 때문에 , B가 주식별자에 의해 함수종속성을 갖는다고 해야 마즘
 
## 3. 속성의 특성에 따른 분류가 아닌것은!
1. 기본속성
2. 파생속성
3. 설계속성

-> 일반방식 : 은 속성의 구성방식에 따른 분류(PK, FK, 일반)

## 4. ERD
- 일대다의 관계 즉, 한명의 고객이 여러 서비스구매가 가능
- 한 고객이 꼭 서비스를 구매하지 않아도 됨
- 서비스 고객이 있다면 반드시 고객이 정의가 되어야 한다.
- 서비스 구매가 일어났다면 반드시 서비스는 존재할 수 밖에 없다.


## 5. 식별자의 특징
- 사원번호 라고 하는 주식별자는 NULL 이 들어갈 수없다.
    => 존재성!!
- 유일성 : 주식별자에 의해 모든 인스턴스가 유일하게 구분되어야한다.
- 너무 많은 컬럼들이 아니라 최소한의 컬럼들로만 속성들로만 구성이 되어있어야함 = 최소성
- 주식별자는 바뀌면 안된다. = 불변성 

## 6.  3차 정규화 => 이행적 종석을 없애는 단계


## 7.  개인회원 또는 법인회원 둘 중 하나로 주문 가능할 경우 고객과 주문 엔터티는 ***상호배타적!!!!!*** 관계이다.
상호포함적 NO!!

## 8. 트랜잭션
- 하나의 연속적인 업무 단위를 말함
- 트랜잭션에 의한 관계는 필수적인 관계 형태를 가짐
- 하나의 트랜잭션에는 하나 이상의 SQL 문장이 포함
- 트랜잭션의 특징
    1. 원자성 : 트랜잭션 정의된 연산들 모두 성공적으로 실행되던지 아니면 전혀 실행되지 않는 상태로 남아 있어야 함
    2. 일관성 : 트랜잭션 실행 전 데이터베이스 내용이 잘못되어 있지 않다면 트랜잭션 실행 이후에도 데이터베이스 내용이 잘못이 있으면 안됨
    3. 고립성 : 트랜잭션 실행도중 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안됨
    4. 지속성 : 트랜잭션이 성공적으로 수행되면 갱신한 데이터베이스 내용이 영구적으로 저장.

## 9.  NULL 
- NULL 로만 구성된 집합을 COUNT 하면 0으로 나옴.!! 

## 10.  식별자
- 엔터티 내의 여러 인스턴스 중 하나를 유일하게 구분할 수 있으나, 대표성을 가지지 못하는 식별자
=> 주식별자 반대: 보조식별자
- 인조식별자의 반대는 본질식별자
- 복합의 반대는 단일식별자

---
---
## 2과목

## 11.  SELECT 문
- 1. 오라클에서는 GROUP BY 절 위에 HAVING 절을 명시할 수 있다. => 가능은 하지만 가급적 GROUP BY 밑에 HAVING 절을 넣는 것을 권장
- 2.
- 3. FROM 절은 모든 DBMS 에서 생략 절대 불가능!!!!!!!
- 4. SELECT 절에 DISTINCT 는 항상 SELECT 바로 뒤에 위치한다.!@@@!!!!!!

## 12. SQL의 종류와 해당하는 명령어

1. DML -  데이터의 삽입INSERT, 수정UPDATE, 삭제DELETE, 병합MERGE
2. TCL - 트랜잭션 제어어, COMMIT, ROLLBACK, SAVEPOINT
3. DCL - 데이터 제어어로 객체에 대한 권한부여(GRANT) 하거나 회수(REVOKE)
4. DDL - 데이터 정의어, 데이터 구조 정의 CREATE,ALTER,DROP,TRUNCATE(데이터삭제) , AUTO COMMIT(명령어 수행하면 즉시 저장, 원복 불가)


## 13. 컬럼 별칭
컬럼 별칭은 SELECT절에서 정의를 하는데 , 순서상 SELECT절 이후에 수행되는 구문은 OREDER BY 절이 유일하다. 따라서 SELECT 과거에 수행된 절에서는 컬럼 별칭을 수행할 수 없으므로, WHERE절에서는 사용불가능  


## 14. 함수 실행 결과
    1. SUBSTR = 문자열 추출 결과 함수
    2. LPAD = 삽입(왼쪽에 삽입) 
- EX. LPAD('X', 5, 'X') 는 첫번째 'X' 즉 원본에다가, 맨 마지막 'X'를 삽입해서 총 5글자를 만드는것 @@!!@@ 5개 넣는거 아님1`!@~!~!~!~!~!!!!
3. INSTR = 문자열의 위치를 찾는 함수
- EX. INSTR('WWW.HDATALAB.CO.KR','.',5,2) : 16
    -> . 을 찾는데 다섯번째 글자부터 찾아서 2번째 발견된 . 의 위치
4. LIRIM : 왼쪽에서 제거하는것 근데 제거를 계속 하다가 제거하면 안되는 문자열을 만나면 즉시 제거 종료됨


## 15. 👀 자주 출제 ) 함수의 실행결과
1. CEIL(3.5) : 4 = > 천장, 3.5 보다 큰애중에 가장 가까운 정수
2. FLOOR(3.5) : 3 => 바닥, 3.5 보다 작은 애중에 가장 가까운 정수
3. ROUND(12345.678, -2):12300 => 반올림인디, -2 가 나오면 일의자리-> 십의자리 에서 반올림 하는거~!~!~!~
4. SIGN(120) :1 => 양수음수를 판별하는 함수 양수면 1 음수면 -1 0이면 0


## 16. NULL 치환함수
1. `NVL` 과 `ISNULL` 은 NVL(COMM, 100) 일 때 COMM값이 NULL이면 100을 NULL이 아니면 원래 값을 리턴해준다.
2. `COALESCE` 은 인수가 여러값이 들어올수있는데 NULL이 아닌 가장 앞에 있는 값을 리턴하는 함수이다. 즉, COMM 이 NULL이 아니면 100, 두번째 인수값이 NULL이면 세번째 인수값 리턴 ~~~ 이런식으로 작동됨
3. `NULLIF` 는 두 값이 같냐 안같냐는 판단하는 함수 즉 COMM = 100 인지 판별한다.같지 않을 때는 첫번째값 리턴, 같으면 NULL 


## 17. DECODE
- `DECODE` 는 대소를 비교하지 못함. 첫번째 인수의 값이 두번째 인수의 값과 같으면이라는 조건을 쓰는데 대소를 비교하고 싶으면 `SIGN` 함수를 쓰면 됨  
![alt text](image.png)
=> SIGN(SAL-4000) => SAL에서 -4000 한 값이 양수냐 음수냐?
-> 저 문제에서는 DECODE 결과값이 같으면 1, 다르면 0을 반환

## 18. CASE WHEN
![alt text](image-1.png)
CASE 구문일때는 WHEN 이 앞에 올때는 묵시적 형변환이 일어나서 상관없지만
뒤쪽에 올 경우 반드시 타입을 일치시켜줘야한다.

## 19. TO_DATE
????????????????????????????????????????????????????

## 20. COUNT
- COUNT 로 10번인 애들만 셀때는 ELSE 를 부여하면 안됨.
- ELSE를 생략하게 되면 NULL 이 치환이 됨 => NULL은 COUNT 가 세지 않기 때문에 딱 그 대상만 카운트할 수 있음
- SUM 에는 ELSE 를 생략하게 되면 NULL 로 만 이루어져있는경우, SUM의 결과값이 NULL로 나오기 때문에 NVL을 붙여서 0으로 치환된 값을 도출하자

## 21. _ 랑 % 
- %A% => A가 포함되기만 하면 됨
- 단, OR 조건은 둘 다 만족하는 애들은 빼줘야함. 3ㄷㄷ4ㄷ;;ㄷ;ㄷ';;;;

## 22. 연산자 우선순위
